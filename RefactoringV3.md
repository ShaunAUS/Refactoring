# 전역데이터(=static)

![](https://velog.velcdn.com/images/wnsqud70/post/bf2fd8d7-f028-4fd2-95f5-cdd14e13fe60/image.png)

- 전역 데이터는 **아무곳에서나 변경될 수 있다는 문제**가 있다.
- 어떤 코드로 인해 값이 바뀐 것인지 파악하기 어렵다.

- **클래스 변수도 비슷한 문제**를 겪을 수 있다.

=> **변수 캡슐화**하기 적용!

### 전역데이터/변수 캡슐화

![](https://velog.velcdn.com/images/wnsqud70/post/a2a06b3c-ad78-430e-8dcf-074a68769d78/image.png)

![](https://velog.velcdn.com/images/wnsqud70/post/2a5ab438-f4f1-4f94-b68c-dfaf4accac29/image.png)

- 이것을 적용해서 접근을 제어하거나 어디서 사용하는지 파악하기 쉽게 만들수 있다.

- 허용되지않는 , 말도안되는 값이 들어오는것을 방지하기위해 우리는 **validation 을 쓰는데 이런것들은 메서드로 감싸져있어야 적절한 사용이 가능**하다

- **글로벌한 데이터 접근가능하게 하는것은 보통 상수 , final값들이다**

- 메소드는 점진적으로 새로운 메서드로 변경가능하지만 , 데이터는 한번에 모두 변경해야한다.

### 결론
> 1. 데이터 사용범위가 global 일경우느 더더욱 메서드로 감싸주자(그만큼 수정을쉽게하면 전코드에 영향을 쉽게주니까)
2. global 할수록 사이드이팩트가 심하다 -> 메서드로 감싸고 +Validation 추가

# 가변데이터

- 데이터 변경을 하다보면 예상치 못했던 결과나 해결하기 어려운 버그가 발생하기도 한다.

## 사용할 수 있는 리팩토링 기술

> - **변수 캡슐화** = 데이터를 변경할수 있는 메소드를 제한하고 관리
- **코드 정리하기** = 데이터를 변경하는 코드를 분리하고 피할수 있다.
- **변수 쪼개기** = 여러 데이터를 저장하는 변수를 나눌수 있다.
- **함수 추출하기** = 이것으로 데이터를 변경하는 코드로부터 사이드 이펙트가 없는 코드를 분리할수 있다.
- **질의 함수와 변경 함수 분리하기** = 클라가 원하는 경우에만 사이드 이팩트가 있는 함수를 호출하도록 API 개선 가능
- **파생 변수를 질의 함수로 바꾸기** = 계산해서 알아낼 수 있는 값에  적용한다.
- **여러 함수를 클래스로 묶기** = 변수가 사용되는 범위를 제한
- **참조를 값으로 바꾸기** = 데이터 일부를 변경하기보다는 데이터 전체를 교체

- 양이 많지만 그리 어렵지 않다. 한번보자

### 가변데이터/변수쪼개기

- **반복문 순회, 데이터 축척용 변수** 말고 그밖에 재할당 되는 변수가 있다면 한번쯤 변수 쪼개기를 생각해보자

- **변수 하나당 하나의 책임을 지도록 만든다.**

![](https://velog.velcdn.com/images/wnsqud70/post/b4f830d7-49aa-4435-9fe5-f4c4b443b6a8/image.png)

![](https://velog.velcdn.com/images/wnsqud70/post/04cdabab-d66c-4c41-84a3-49362fb9b3c2/image.png)

- 똑같은 변수가 여기 저기쓰이면 헷갈리기도하고 가독성도 안좋다, 변수하나당 하나의 책임을 가지도록 만들어주자

![](https://velog.velcdn.com/images/wnsqud70/post/f7cc462b-8558-4bff-a710-c272553bb0a1/image.png)

- result는 **값을 축척하는 용도**로 사용해서 괜찮다.

- **반복문 순회, 데이터 축척용은 괜찮다.**

### 가변데이터/ 질의 함수와 변경 함수 분리하기

- **"눈에 띌만한" 사이드 이펙트 없이 값을 조회할 수있는 메소드**는 테스트 하기도 쉽고 메소드를 이동하기도 편하다

- **어떤 값을 리턴하는 함수 (조회) 는 사이드 이펙트가 없어야 한다.**

- **캐시는 중요한 객체 상태 변화가 아니라** 어떤 메소드의 사이드 이펙트로 캐시데이터를 변경하더라도 분리할 필요 없다.

- **조회함수와 변경함수(modifier) 를 구분하자**

![](https://velog.velcdn.com/images/wnsqud70/post/ea3f3706-0603-42b9-a491-88dfefcccfe4/image.png)

![](https://velog.velcdn.com/images/wnsqud70/post/a47ae9d2-39af-45f9-8eae-4daafe01d9c7/image.png)

- 메서드 하나에서 result라는 값을 리턴하며 sendBill()이라는 메서드도 수행한다.

- 두개의 역활을 하는 **메서드를 하나의 역활만 하도록 나누자**   ( 조회와 변경을 나누자!)


![](https://velog.velcdn.com/images/wnsqud70/post/918c5b6b-e760-4e87-857e-e4c0b1b14328/image.png)

- 이것 또한 **조회와 modifier가 같이 있는 메서드**이다! 나누어보자

![](https://velog.velcdn.com/images/wnsqud70/post/c8f957c5-8946-4922-8080-56f9e3d2a5f7/image.png)

- 조회와 Modifier을 나눴다. 하지만 코드가 중복됀다. 이것도 정리를 하면

![](https://velog.velcdn.com/images/wnsqud70/post/47dce1ac-cc68-4cc4-b31a-b856ee3c9f8c/image.png)


- 이렇게 최종적으로 조회와 Modifier을 분리해냈다.


### 가변데이터/ 세터 제거하기 

- 세터가 제공된다는 것은 해당 필드가 변경될수 있다는 뜻이다.

- 안전한 데이터를 위해 **세터를 없애고 생성자로만 값초기화**를 가능 하도록 한다.

### 가변데이터/ 파생 변수를 질의 함수로 바꾸기








